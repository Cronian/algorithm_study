1. 퀵 정렬 (Quick)
- 분할 정복 알고리즘(divide and conquer)을 사용
- 반복문을 하나만 사용하는 대신 재귀호출을 사용하여 정렬
- 데이터가 적은 경우보다 많은 경우 성능이 급격히 좋아짐
- 이미 데이터가 정렬되어있는 최선의 경우나 역순으로 정렬되어있는 경우(최악의 경우) 성능이 많이 나빠짐
- 장점 : 빠른속도, 구현하기 쉬움, 메모리 사용량 적음
- 시간 복잡도 : 최선( O(NlogN) ), 평균( O(NlogN) ), 최악( O(N^2) )

2. 기수 정렬 (Radix)
- 정렬할 데이터의 자릿수를 이용해 데이터를 정렬하는 방법
- 자릿수로 데이터를 정렬
- 1의 자릿수로 정렬 -> 10의 자릿수로 재정렬 -> 100의 자릿수로 재정렬 ....
- 데이터의 비교와 이동횟수가 거의 없음
- 시간 복잡도 : 최선( O(D(N+Q)) ), 평균( O(D(N+Q)) ), 최악( O(D(N+Q)) ) ( D: 데이터의 자릿수, N : 정렬할 데이터 수, Q: 큐의 수)

3. 병합 정렬 알고리즘 (Merge)
- 이미 정렬되어있는 데이터들을 하나로 합하여 정렬하는 방법
- 3-way, 2-way 병합 정렬 알고리즘 (주로 2-way 사용)
- 정렬되지 않은 데이터들을 그룹으로 묶어가며 정렬
- 정렬할 데이터의 양이 많아질수록 성능이 나빠찜
- 시간 복잡도 : 최선( O(NlogN) ), 평균( O(NlogN) ), 최악( O(NlogN) )

4. 힙 정렬 알고리즘 (Heap)
- 운영체제나 네트워크 등 시스템 내부에서 가장 많이 사용하는 정렬 알고리즘
- 트리 구조로 구성되며 루트 노드가 가장 큰 값을 가짐
- 힙의 가장 뒤에 데이터를 삽입 후 데이터의 위치를 재구성 ( 업힙과 다운힙 )
- 업힙 : 재구성 할 때 데이터가 점점 위로 올라가는 형태
- 다운힙 : 재구성 할 때 데이터가 점점 아래로 내려가는 형태
- 장점 : 시간 복잡도의 성능 차이가 거의 없다 -> 안정된 알고리즘
- 정렬할 데이터의 수에 성능이 크게 의존적이지 않다
- 시간 복잡도 : 최선( O(NlogN) ), 평균( O(NlogN) ), 최악( O(NlogN) )
